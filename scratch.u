view : Model -> Text
view m =
  let
    intToNat : Int -> Optional Nat
    intToNat n =
      if n < +0
        then None
        else Some (truncate0 n)

    replaceAt : Int -> Int -> a -> [[a]] -> [[a]]
    replaceAt xInt yInt a matrix =
      case (intToNat xInt, intToNat yInt) of
        (Some x, Some y) ->
          case at y matrix of
            None -> matrix
            Some list ->
              replace y (replace x a list) matrix

        _ ->
          matrix

    -- assuming width of 80 and height of 40
    replaceCoordinate : Int -> Int -> a -> [[a]] -> [[a]]
    replaceCoordinate x y a =
      replaceAt (x + +40) (negate y + +20) a

    case m of
      Model (x,y) ->
          emptyBoard : [[Char]]
          emptyBoard = repeat 40 (repeat 80 ?\s)

          board = replaceCoordinate x y ?+ emptyBoard

          showLine t = "|" Text.++ fromCharList t ++ "|"

          barLine = repeat 80 ?-

          unlines
            (List.map
              showLine
              (barLine +: board :+ barLine))

---

-- .ian.game.hardtack

unique type Model = Model (Int, Int)

unique type Input = North | South | East | West

play _ = run hardtack

hardtack : UI Model Input
hardtack = UI init view update parseInput

init : Model
init = Model (+10, +10)

update : Input -> Model -> Model
update i m =
  case m of
    Model (x,y) ->
      case i of
        Input.North -> Model (x, y + +1)
        Input.South -> Model (x, y - +1)
        Input.East  -> Model (x + +1, y)
        Input.West  -> Model (x - +1, y)

view : Model -> Text
view _ =
  let
    board : [Text]
    board = repeat 30 ""

    unlines
      (map
        (t -> "|" ++ t)
        ([ fromCharList (repeat 80 ?-) ] ++ board))

> view Model

parseInput : Text -> Either Text Input
parseInput t =
  if t == "w" then Right North
  else
    if t == "s" then Right South
    else
      if t == "d" then Right East
      else if t == "a" then Right West else Left "Not recognized"

-- .ian.cli.mvu

unique type UI model input =
  { init : model
  , view : model -> Text
  , update : input -> model -> model
  , parseInput : Text -> Either Text input
  }

run : UI model input ->{IO} ()
run ui =
  loop m =
    printLine (UI.view ui m)
    str = !readLine
    case UI.parseInput ui str of
      Left e ->
        printLine e
        loop m
      Right input -> loop (UI.update ui input m)
  loop (UI.init ui)

-- .ian.Nat

decrement : Nat -> Optional Nat
decrement n =
  if n == 0
    then None
    else Some (Int.truncate0 (Nat.toInt n Int.- +1))

-- these didn't work:
-- (got: The expression in red needs the {.builtin.io.IO} ability, but this location does not have access to any abilities.)
--
-- use test.v1
-- test> tests.decrement.ex1 = run (expect (decrement 0 == None))
-- test> tests.decrement.ex2 = run (expect (decrement 1 == Some 0))
-- test> tests.decrement.ex3 = run (expect (decrement 2 == Some 1))

-- .ian.List

repeat : Nat -> a -> [a]
repeat n a =
  let
    f : Nat -> Optional (a, Nat)
    f x =
      map (y -> (a,y)) (Nat.decrement x)

    unfold n f

> repeat 5 "A"

intersperse : a -> [a] -> [a]
intersperse separator xs =
  let
    f : [[a]] -> a -> [[a]]
    f acc y =
      acc :+ [separator,y]

    case xs of
      [] ->
        []

      y +: ys ->
        join (foldl f [[y]] ys)

> intersperse 0 [1,2,3,4]

-- .ian.Text

unlines : [Text] -> Text
unlines =
  foldl (acc t -> acc ++ t ++ "\n") ""

> unlines ["aaa","bbb","ccc"]
